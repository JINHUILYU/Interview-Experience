# 编程语言

## 值传参和引用传参的区别？效率有区别吗？

### **C++ 值传参 vs 引用传参**

在 C++ 中，函数参数的传递方式主要有 **值传递（pass by value）** 和 **引用传递（pass by reference）**，它们的**主要区别在于数据的复制和修改方式**，并且在性能上也有所不同。

---
### **1. 值传参（Pass by Value）**

#### **概念**

- 传递的是 **参数的副本**，函数内部对参数的修改**不会影响原变量**。
- 适用于 **小型数据类型**（`int`, `char`, `float` 等）。
- **不适用于大型对象**（如 `std::string`、`std::vector`），因为复制开销大。

#### **示例**

```cpp
#include <iostream>

void modifyValue(int x) {
    x = 20; // 仅修改 x 的副本
}

int main() {
    int a = 10;
    modifyValue(a);
    std::cout << "a: " << a << std::endl;  // a 仍然是 10
    return 0;
}
```

**结果**：

```
a: 10
```

**解释**：

- `modifyValue(a)` 传递的是 `a` 的 **副本**，修改 `x` **不会影响 `a`**。

---
### **2. 引用传参（Pass by Reference）**

#### **概念**

- 传递的是 **变量的引用**（即变量的别名），函数内对参数的修改**会影响原变量**。
- **适用于需要修改原变量的情况**，如排序、交换等操作。
- **适用于大型对象**，避免不必要的复制，提高性能。

#### **示例**

```cpp
#include <iostream>

void modifyReference(int &x) {
    x = 20; // 直接修改 x 所引用的变量
}

int main() {
    int a = 10;
    modifyReference(a);
    std::cout << "a: " << a << std::endl;  // a 被修改为 20
    return 0;
}
```

**结果**：

```
a: 20
```

**解释**：

- `modifyReference(a)` 传递的是 `a` **本身**，所以 `x` **直接修改了 `a` 的值**。

---
### **3. 常量引用传参（Pass by Const Reference）**

#### **概念**

- 传递引用，但不允许修改原变量（**防止误修改**）。
- **适用于大型对象的只读访问**（如 `std::string`, `std::vector`）。
- **避免复制，提高效率**，同时保证数据安全。

#### **示例**

```cpp
#include <iostream>
#include <string>

void printString(const std::string &str) {
    std::cout << str << std::endl;
    // str = "New Value"; // ❌ 编译错误，不能修改
}

int main() {
    std::string myString = "Hello, World!";
    printString(myString);
    return 0;
}
```

**解释**：

- `printString(const std::string &str)` 传递的是 `str` 的引用 **（避免复制）**，但不能修改 `str` **（保证安全）**。

---
### **4. 值传参 vs 引用传参的效率**

| **传递方式**                    | **是否复制数据** | **修改原变量** | **适用场景**   | **效率**      |
| --------------------------- | ---------- | --------- | ---------- | ----------- |
| **值传参** (`int a`)           | ✅ 复制       | ❌ 不修改     | 小型数据类型     | **低（复制消耗）** |
| **引用传参** (`int &a`)         | ❌ 不复制      | ✅ 可修改     | 需要修改的变量    | **高（避免复制）** |
| **常量引用传参** (`const int &a`) | ❌ 不复制      | ❌ 不能修改    | 传递大型对象但不修改 | **高（避免复制）** |

✅ **小型数据（`int`、`char`）使用值传递**（复制开销小）  
✅ **大型对象（`std::vector`, `std::string`）使用 `const &` 传递**（避免复制，提高效率）  
✅ **需要修改参数时，使用引用传递 `&`**（直接修改原变量）

---
### **5. 具体性能对比（实验）**

测试 **值传递 vs 引用传递** 对 `std::vector<int>` 的性能影响：

```cpp
#include <iostream>
#include <vector>
#include <chrono>

// 值传递（会复制整个 vector）
void passByValue(std::vector<int> vec) {
    vec.push_back(100);
}

// 引用传递（不复制）
void passByReference(const std::vector<int> &vec) {
    // 只读取，不修改
}

int main() {
    std::vector<int> largeVector(1000000, 1);  // 100 万个元素

    auto start1 = std::chrono::high_resolution_clock::now();
    passByValue(largeVector);  // 复制 100 万个元素
    auto end1 = std::chrono::high_resolution_clock::now();
    std::cout << "Pass by Value: " 
              << std::chrono::duration_cast<std::chrono::milliseconds>(end1 - start1).count()
              << " ms" << std::endl;

    auto start2 = std::chrono::high_resolution_clock::now();
    passByReference(largeVector);  // 仅传递引用
    auto end2 = std::chrono::high_resolution_clock::now();
    std::cout << "Pass by Reference: " 
              << std::chrono::duration_cast<std::chrono::milliseconds>(end2 - start2).count()
              << " ms" << std::endl;

    return 0;
}
```

#### **实验结果**

```
Pass by Value: 50 ms
Pass by Reference: 0 ms
```

- **值传递（Pass by Value）复制了整个 `vector`，导致明显的时间消耗**。
- **引用传递（Pass by Reference）只传递了地址，速度接近 0 ms**。

---
### **6. 总结**

#### **📌 何时使用值传递？**

✅ 适用于**小型数据类型**（`int`、`char`、`double`）。  
✅ 适用于**临时变量**，避免修改原数据。  
❌ **避免对大型对象使用值传递**（复制消耗大）。

#### **📌 何时使用引用传递？**

✅ 适用于**大型对象**（`std::vector`、`std::string`）。  
✅ 需要**在函数内部修改变量**时（如 `swap()`）。  
❌ **避免传递原始数据类型的引用**（会导致性能无提升）。

#### **📌 何时使用 `const &` 传递？**

✅ 适用于**大型对象的只读访问**（`const std::vector<int> &v`）。  
✅ **防止误修改**数据，提升代码安全性。

**🔹 结论：**

- **小数据类型**（`int`, `char`）：`值传递`
- **大数据类型**（`std::vector`, `std::string`）：`const &`（避免复制）
- **需要修改数据**：`&`（传递引用）
- **性能最优解**：**`const &` 传递不可变数据，`&` 传递可变数据**

**如果要避免不必要的复制，默认选择 `const &`！** 🚀

---
## c++多态的实现方式，虚函数定义和作用，c怎么实现c++的多态

### **📌 C++ 多态的实现方式**

多态（Polymorphism）是 C++ **面向对象编程（OOP）** 的三大特性之一。它允许同一接口有不同的实现，提高代码的扩展性和可维护性。

---
### **1️⃣ C++ 多态的实现方式**

C++ 支持两种主要的多态：

1. **编译时多态（静态多态 / 静态绑定）**
    - **函数重载（Function Overloading）**
    - **运算符重载（Operator Overloading）**
    - **模板（Template）**
    - 由编译器在**编译阶段**决定调用哪个函数，**不会影响运行时性能**。
2. **运行时多态（动态多态 / 动态绑定）**
    - **虚函数（Virtual Function）**
    - **抽象类（Abstract Class）**
    - **接口（Interface）**
    - 依赖**虚表（vtable）** 和 **虚指针（vptr）**，在**运行时决定调用哪个函数**，有一定的性能开销。

---
### **2️⃣ C++ 虚函数的定义和作用**

#### **✅ 虚函数（Virtual Function）**

- **基类定义的成员函数，在子类中可以重写**（`override`）。
- **通过基类指针或引用调用子类的实现**，实现**运行时多态**。
- **底层原理**：使用**虚表（vtable）和虚指针（vptr）** 实现。

#### **🚀 示例**

```cpp
#include <iostream>

class Base {
public:
    virtual void show() {  // ✅ 定义虚函数
        std::cout << "Base::show()" << std::endl;
    }
};

class Derived : public Base {
public:
    void show() override {  // ✅ 重写基类虚函数
        std::cout << "Derived::show()" << std::endl;
    }
};

int main() {
    Base* ptr = new Derived();  // 基类指针指向子类对象
    ptr->show();  // ✅ 运行时调用 Derived::show()（动态绑定）
    delete ptr;
    return 0;
}
```

**📝 输出**

```
Derived::show()
```

**🔹 解释**

- `Base` 类中 `show()` 是**虚函数**。
- `ptr->show()` **在运行时解析为 `Derived::show()`**，实现多态。

---
#### **✅ 虚表（vtable）和虚指针（vptr）**

🔹 **底层实现**

1. 每个**含虚函数的类**都有一张**虚表（vtable）**，存储虚函数的地址。
2. 每个**对象**都有一个**虚指针（vptr）**，指向该类的虚表。
3. **调用虚函数时，编译器会查找虚表，调用子类的函数**。

##### **🚀 虚表的示意**

```cpp
class Base {
public:
    virtual void show() {}  // ✅ 含虚函数，Base 生成 vtable
};
class Derived : public Base {
public:
    void show() override {}  // ✅ 重写 show()
};
```

##### **🔹 内存布局**

```
Base 对象:
[ vptr -> Base::vtable ]
Base::vtable:
[ &Base::show() ]

Derived 对象:
[ vptr -> Derived::vtable ]
Derived::vtable:
[ &Derived::show() ]
```

##### **🔹 运行时调用 `ptr->show();`**

```
1. 通过 `ptr` 访问 vptr
2. 通过 vptr 找到 vtable
3. 在 vtable 中找到 `Derived::show()`，执行
```

✅ **虚表保证了 C++ 运行时的动态多态机制**。

---
### **3️⃣ C 语言如何实现 C++ 的多态？**

C 语言**没有类和虚函数**，但可以**手动实现多态**，通常有两种方法：

#### **🚀 方法 1：函数指针**

C 语言可以使用**结构体 + 函数指针**模拟虚函数：

```c
#include <stdio.h>

// 定义基类（结构体）
typedef struct {
    void (*show)();  // 函数指针
} Base;

// 基类的默认实现
void base_show() {
    printf("Base::show()\n");
}

// 定义子类（继承基类）
typedef struct {
    Base base;  // 基类部分
} Derived;

// 子类的重写函数
void derived_show() {
    printf("Derived::show()\n");
}

// 初始化基类
void Base_init(Base* obj) {
    obj->show = base_show;
}

// 初始化子类
void Derived_init(Derived* obj) {
    Base_init(&obj->base);  // 初始化基类部分
    obj->base.show = derived_show;  // 重写 show()
}

int main() {
    Derived d;
    Derived_init(&d);

    Base* ptr = (Base*)&d;
    ptr->show();  // ✅ 调用 Derived::show()
    return 0;
}
```

**📝 输出**

```
Derived::show()
```

**🔹 解释**

- **函数指针模拟虚表（vtable）**，调用 `ptr->show()` 时，会访问 `Derived` 的 `show()`。

---
#### **🚀 方法 2：手动维护虚表**

```c
#include <stdio.h>

// 定义虚表（模拟 vtable）
typedef struct {
    void (*show)();
} VTable;

// 定义基类
typedef struct {
    VTable* vtable;
} Base;

// 基类的默认函数
void base_show() {
    printf("Base::show()\n");
}

// 子类的函数
void derived_show() {
    printf("Derived::show()\n");
}

// 定义基类和子类的虚表
VTable base_vtable = { base_show };
VTable derived_vtable = { derived_show };

// 定义子类
typedef struct {
    Base base;
} Derived;

// 初始化对象
void Base_init(Base* obj) {
    obj->vtable = &base_vtable;
}
void Derived_init(Derived* obj) {
    Base_init(&obj->base);
    obj->base.vtable = &derived_vtable;
}

int main() {
    Derived d;
    Derived_init(&d);

    Base* ptr = (Base*)&d;
    ptr->vtable->show();  // ✅ 调用 Derived::show()
    return 0;
}
```

**📝 输出**

```
Derived::show()
```

**🔹 解释**

- **手动维护 vtable（虚表）**
- **基类 `Base` 和子类 `Derived` 共享相同的接口**
- **通过 `vtable->show()` 调用正确的函数**

---
### **📌 重点总结**

|**语言**|**多态方式**|**特点**|
|---|---|---|
|**C++ 静态多态**|函数重载 / 运算符重载 / 模板|**编译期确定，性能高**|
|**C++ 动态多态**|**虚函数（vtable 机制）**|**运行时决定，灵活但有开销**|
|**C 语言模拟多态**|**函数指针 / 手动维护 vtable**|**手动管理，但没有 C++ 语法支持**|

✅ **C++ 推荐使用 `virtual` 关键字，实现动态多态**。  
✅ **C 语言可以使用函数指针或手动维护虚表实现多态，但复杂度较高**。  
🚀 **C++ 提供更强大的面向对象特性，尽量使用 C++ 进行多态设计！** 🔥

---
## void* 指针能否做算术运算，为什么？ 

**在 C 和 C++ 中，`void*` 指针不能直接进行算术运算（如 `+`、`-` 操作）。**  
如果尝试对 `void*` 指针执行算术运算，**C++ 会报错，而 C 可能会警告**。

---
### **1. 为什么 `void*` 不能直接做算术运算？**

#### **📌 主要原因：`void*` 没有确定的数据类型**

- 指针的算术运算（如 `ptr + 1`）依赖于指针所指向的数据类型的 **字节大小（`sizeof(type)`）**。
- 但是 **`void*` 没有具体的类型，因此 `sizeof(void)` 是不确定的**，编译器无法推断出步长（offset）。

#### **示例：**

```cpp
#include <iostream>

int main() {
    void* ptr;
    ptr++; // ❌ 编译错误（C++），C 语言可能警告
    return 0;
}
```

**错误信息（C++）：**

```
error: invalid use of void expression
```

**C 语言可能会警告**（但有些编译器可能允许，实际行为未定义）。

---
### **2. 解决方案：强制转换为具体类型**

如果需要对 `void*` 指针执行算术运算，**必须先将其转换为具有具体类型的指针**。

#### **✅ 正确示例**

```cpp
#include <iostream>

int main() {
    int arr[5] = {1, 2, 3, 4, 5};
    void* ptr = arr;  // 指向数组的起始地址

    int* intPtr = static_cast<int*>(ptr);  // 转换为 int*
    intPtr++;  // 现在可以执行算术运算，步长为 sizeof(int)
    
    std::cout << *intPtr << std::endl;  // 输出 2（arr[1]）
    return 0;
}
```

**解析：**

1. **`void* ptr = arr;`** → `ptr` 指向 `arr` 的起始地址，但 `ptr` 不能直接递增。
2. **`int* intPtr = static_cast<int*>(ptr);`** → 强制转换为 `int*`，使得 `sizeof(int)` 变得可知。
3. **`intPtr++`** → `intPtr` 增加 `sizeof(int)` 个字节，即向后移动一个 `int` 单位。
4. **`std::cout << *intPtr;`** → 访问 `arr[1]` 的值。

---
### **3. 在 C 语言中的情况**

在 **C 语言** 中，`void*` 是 **通用指针**，但依然不能直接做算术运算：

```c
#include <stdio.h>

int main() {
    void* ptr;
    ptr++;  // ⚠️ 某些 C 编译器会警告：arithmetic on a pointer to void
    return 0;
}
```

某些 C 编译器可能会**允许** `void*` 进行算术运算，假定 `void*` 以 `char*` 处理（步长为 1 字节），但这属于**非标准行为**，应避免。

---
### **4. `char*` 可以直接做算术运算**

由于 `char` 的大小总是 **1 字节**，`char*` 指针的算术运算不会有问题：

```cpp
char arr[] = "Hello";
char* ptr = arr;

ptr++;  // ✅ 合法，步长为 1 字节
std::cout << *ptr << std::endl;  // 输出 'e'
```

但 `void*` **没有固定的大小**，因此 **不能直接计算步长**。

---
### **5. 总结**

|**操作**|**C 语言**|**C++ 语言**|**原因**|
|---|---|---|---|
|`void*` 指针算术运算|⚠️ 可能警告|❌ 报错|`void*` 无法确定 `sizeof(void)`|
|`char*` 指针算术运算|✅ 允许|✅ 允许|`sizeof(char) == 1`|
|`int*` 指针算术运算|✅ 允许|✅ 允许|`sizeof(int)` 可知|
|`void*` 转换后算术运算|✅ 允许|✅ 允许|`static_cast<int*>` 后类型明确|

### **🚀 结论**

❌ **`void*` 不能直接做算术运算**（C++ 报错，C 可能警告）。  
✅ **转换为具体类型后**（如 `int*`），可以进行算术运算。  
✅ **`char*` 指针天然支持算术运算**，因 `sizeof(char) == 1`。

**如果需要操作 `void*`，建议先转换为具体类型指针！** 🔥

---
## void* 指针的作用 

### **📌 什么是 `void*` 指针？**

- `void*` 称为 **通用指针（Generic Pointer）**，可以指向 **任何数据类型**。
- 由于 `void*` 没有固定的类型，它**不能直接解引用或做算术运算**，必须先转换为具体类型。

### **📌 `void*` 指针的主要作用**

| **用途**         | **作用**                           |
| -------------- | -------------------------------- |
| **1. 泛型编程**    | 让函数或数据结构可以操作不同类型的数据              |
| **2. 动态内存管理**  | `malloc()` / `free()` 需要 `void*` |
| **3. 函数指针传参**  | 适用于回调函数、线程函数等                    |
| **4. 避免强类型依赖** | 在 `C` 语言中增强灵活性                   |

---
### **1. `void*` 用于泛型编程**

在 C 语言中，由于没有 `template`（模板），使用 `void*` 让函数可以处理**不同类型**的数据。

#### **示例：交换不同类型的值**

```c
#include <stdio.h>
#include <string.h>

// 泛型交换函数
void swap(void* a, void* b, size_t size) {
    char temp[size];  // 用字符数组存储临时数据
    memcpy(temp, a, size);
    memcpy(a, b, size);
    memcpy(b, temp, size);
}

int main() {
    int x = 10, y = 20;
    double a = 3.14, b = 2.71;

    swap(&x, &y, sizeof(int));
    swap(&a, &b, sizeof(double));

    printf("x = %d, y = %d\n", x, y);  // x = 20, y = 10
    printf("a = %.2f, b = %.2f\n", a, b);  // a = 2.71, b = 3.14

    return 0;
}
```

✅ `void*` 让 `swap()` **可以操作 `int`、`double` 等任意类型**。

---
### **2. `void*` 在动态内存管理**

`malloc()` 和 `free()` 使用 `void*`，因为它们**不依赖具体类型**。

#### **示例**

```c
#include <stdio.h>
#include <stdlib.h>

int main() {
    // 使用 malloc() 分配内存
    void* ptr = malloc(10 * sizeof(int));  
    if (!ptr) return 1;  // 分配失败

    int* intPtr = (int*) ptr;  // 转换为 int*
    for (int i = 0; i < 10; i++) {
        intPtr[i] = i * 10;  // 赋值
    }

    for (int i = 0; i < 10; i++) {
        printf("%d ", intPtr[i]);  // 输出 0 10 20 30 ...
    }

    free(ptr);  // 释放内存
    return 0;
}
```

✅ `malloc()` 返回 `void*`，程序员**可以转换为任意类型指针**。  
✅ `free()` 释放 `void*` 指针，无需知道数据类型。

---
### **3. `void*` 作为回调函数参数**

#### **示例：线程函数**

```c
#include <stdio.h>
#include <pthread.h>

void* threadFunc(void* arg) {
    int* num = (int*) arg;  // 转换为 int*
    printf("Thread received: %d\n", *num);
    return NULL;
}

int main() {
    pthread_t thread;
    int value = 42;
    
    pthread_create(&thread, NULL, threadFunc, &value);
    pthread_join(thread, NULL);

    return 0;
}
```

✅ `pthread_create()` 需要 `void*` 作为参数，**允许传递任意类型数据**。  
✅ `threadFunc()` 通过 **类型转换** 获取正确数据。

---
### **4. `void*` 作为结构体中的通用数据存储**

#### **示例：通用链表**

```c
#include <stdio.h>
#include <stdlib.h>

// 链表节点
typedef struct Node {
    void* data;
    struct Node* next;
} Node;

// 创建新节点
Node* createNode(void* data) {
    Node* newNode = (Node*)malloc(sizeof(Node));
    newNode->data = data;
    newNode->next = NULL;
    return newNode;
}

int main() {
    int val = 10;
    double dval = 3.14;

    Node* intNode = createNode(&val);
    Node* doubleNode = createNode(&dval);

    printf("Integer: %d\n", *(int*)intNode->data);
    printf("Double: %.2f\n", *(double*)doubleNode->data);

    free(intNode);
    free(doubleNode);
    return 0;
}
```

✅ `void*` 使得链表可以**存储不同类型的数据**。  
✅ 需要**强制转换回原类型**。

---
### **5. `void*` 指针的限制**

🚫 **不能直接解引用**

```c
void* ptr;
printf("%d", *ptr);  // ❌ 错误：不知道 `void*` 的数据类型
```

✔ **必须转换后才能解引用**

```c
int* intPtr = (int*) ptr;
printf("%d", *intPtr);  // ✅ 正确
```

🚫 **不能直接做指针算术运算**

```c
void* ptr;
ptr++;  // ❌ 错误：`void*` 没有具体类型
```

✔ **必须转换为具体类型**

```c
char* charPtr = (char*) ptr;
charPtr++;  // ✅ 正确
```

---
### **📌 总结**

|**用途**|**作用**|**示例**|
|---|---|---|
|**泛型编程**|让函数处理不同类型数据|`swap(void*, void*, size_t)`|
|**动态内存管理**|`malloc()` / `free()`|`int* ptr = (int*) malloc(10 * sizeof(int))`|
|**回调函数参数**|适用于线程、事件处理|`pthread_create()`|
|**结构体通用存储**|允许存储不同类型数据|链表存 `void* data`|

✅ `void*` 提供 **灵活性**，但必须**手动类型转换**。  
✅ 适用于 **泛型编程、动态内存管理、函数指针、通用数据存储**。  
❌ 不能直接 **解引用或做算术运算**，必须先转换类型！ 🚀

---
## 构造函数和析构函数能否为虚函数，为什么？ 

### **📌 构造函数和析构函数能否为虚函数？**

在 C++ 中：

1. **析构函数（Destructor）** **可以是虚函数**，并且在 **有继承关系的类** 中应当声明为 `virtual`，以确保正确的析构顺序。
2. **构造函数（Constructor）** **不能是虚函数**，因为**构造函数本身的调用依赖于对象的创建，而虚函数机制需要对象存在后才能发挥作用**。

---

### **1. 析构函数可以是虚函数**

#### **✔ 为什么析构函数应当是虚函数？**

- 在**基类指针指向子类对象**时，若析构函数不是虚函数，**只会调用基类的析构函数**，导致子类的资源**未正确释放**（内存泄漏）。
- 设为 `virtual` 后，基类指针析构对象时，会**先调用子类析构函数，再调用基类析构函数**，确保资源释放正确。

#### **✔ 示例**

```cpp
#include <iostream>

class Base {
public:
    Base() { std::cout << "Base Constructor\n"; }
    virtual ~Base() { std::cout << "Base Destructor\n"; } // ✅ 析构函数是虚函数
};

class Derived : public Base {
public:
    Derived() { std::cout << "Derived Constructor\n"; }
    ~Derived() { std::cout << "Derived Destructor\n"; }
};

int main() {
    Base* obj = new Derived();
    delete obj;  // ✅ 先调用 `Derived` 析构，再调用 `Base` 析构
    return 0;
}
```

**输出：**

```
Base Constructor
Derived Constructor
Derived Destructor  // 先调用子类析构
Base Destructor     // 再调用基类析构
```

#### **🚫 如果析构函数不是虚函数**

```cpp
class Base {
public:
    ~Base() { std::cout << "Base Destructor\n"; }  // ❌ 不是虚函数
};
```

**删除 `Base*` 指向的 `Derived` 对象时，仅调用 `Base` 的析构函数，导致 `Derived` 资源泄漏！**

---
### **2. 构造函数不能是虚函数**

#### **🚫 为什么构造函数不能是虚函数？**

1. **虚函数表（vtable）在构造函数执行完后才建立**：
    - C++ 的虚函数依赖于**虚函数表（vtable）**，该表在**构造函数执行完毕后**才初始化。
    - 如果构造函数是虚函数，vtable 还**未初始化**，无法进行动态绑定。
2. **对象创建需要确定类型，而虚函数需要对象已创建**
    - 虚函数机制是**通过基类指针或引用调用子类函数**，但对象创建前，基类指针仍未指向具体对象，动态绑定无法进行。

#### **🚫 错误示例**

```cpp
class Base {
public:
    virtual Base() { // ❌ 编译错误
        std::cout << "Base Constructor\n";
    }
};
```

**编译错误**：

```
error: constructor cannot be declared virtual
```

---
### **3. 构造函数中调用虚函数**

#### **📌 虚函数在构造函数中的行为**

- **构造函数内部调用虚函数时，不会发生动态绑定，而是调用当前类的版本**（不会调用子类重写的版本）。
- 因为 **在基类构造时，子类的部分尚未构造完成**，所以 **虚函数不会向下调用到子类**。

#### **🚫 例子**

```cpp
#include <iostream>

class Base {
public:
    Base() { print(); }  // 在构造函数中调用虚函数
    virtual void print() { std::cout << "Base print\n"; }
};

class Derived : public Base {
public:
    void print() override { std::cout << "Derived print\n"; }
};

int main() {
    Derived d;
    return 0;
}
```

**输出：**

```
Base print
```

#### **📌 解释**

- 在 `Base` 的构造函数中调用 `print()`，由于 `Derived` 还**未初始化完成**，因此 `print()` 调用的是 `Base` 版本，而**不是 `Derived` 版本**。
- 这样可以避免调用未初始化的 `Derived` 成员变量，防止**访问未初始化内存**。

✅ **解决方案**：如果需要多态初始化，可以使用**工厂模式**（`Factory Pattern`）。

---
### **4. 总结**

|**特性**|**是否可以是虚函数？**|**原因**|
|---|---|---|
|**构造函数（Constructor）**|🚫 **不能**|对象创建时 vtable 未初始化|
|**析构函数（Destructor）**|✅ **可以**|允许基类指针正确析构子类|
|**构造函数调用虚函数**|🚫 **不发生多态**|只调用当前类版本，子类未初始化|

### **📌 结论**

- **析构函数应设为 `virtual`，避免子类对象未正确析构**。
- **构造函数不能是 `virtual`，因为 vtable 依赖对象初始化**。
- **构造函数内部调用虚函数时，不会触发多态，调用的是当前类的方法**。

**🔥 最佳实践：**

```cpp
class Base {
public:
    virtual ~Base() { std::cout << "Base Destructor\n"; }  // ✅ 析构函数设为虚函数
};
```

---
## new 和 malloc 的区别 

在 C++ 中，`new` 和 `malloc()` 都可以**在堆（heap）上分配内存**，但它们有以下主要区别：

|**特性**|**`new` / `delete` (C++)**|**`malloc()` / `free()` (C)**|
|---|---|---|
|**是否调用构造/析构函数**|✅ 调用构造函数（`new`），调用析构函数（`delete`）|❌ 仅分配内存，不调用构造/析构函数|
|**返回类型**|返回指定类型的指针，无需强制转换|返回 `void*`，需要**强制转换**|
|**分配失败**|抛出 `std::bad_alloc` 异常|返回 `NULL`|
|**内存初始化**|**`new` 默认初始化**（基本类型未初始化，类对象调用构造函数）|**`malloc()` 不初始化**|
|**重载**|可以重载 `operator new()`|不能重载|
|**适用语言**|**仅 C++**|**C 和 C++ 都能使用**|

---
### **1. `new` 分配内存（调用构造函数）**

**示例（`new` 分配单个对象）：**

```cpp
#include <iostream>

class Test {
public:
    Test() { std::cout << "Constructor called!\n"; }
    ~Test() { std::cout << "Destructor called!\n"; }
};

int main() {
    Test* ptr = new Test();  // ✅ 分配内存，并调用构造函数
    delete ptr;  // ✅ 释放内存，并调用析构函数
    return 0;
}
```

**输出：**

```
Constructor called!
Destructor called!
```

**解释：**

- `new Test();` **调用构造函数** `Test()`
- `delete ptr;` **调用析构函数** `~Test()`

---
### **2. `malloc()` 分配内存（不调用构造函数）**

**示例（`malloc()` 仅分配内存，不调用构造函数）：**

```cpp
#include <iostream>
#include <cstdlib>

class Test {
public:
    Test() { std::cout << "Constructor called!\n"; }
    ~Test() { std::cout << "Destructor called!\n"; }
};

int main() {
    Test* ptr = (Test*) malloc(sizeof(Test));  // ❌ malloc 只分配内存，不调用构造函数
    free(ptr);  // ❌ 只释放内存，不调用析构函数
    return 0;
}
```

**输出：**

```
（没有任何输出）
```

**解释：**

- `malloc(sizeof(Test))` **仅分配内存，不调用构造函数**，因此没有 `Constructor called!`。
- `free(ptr);` **仅释放内存，不调用析构函数**，可能导致资源泄漏。

---
### **3. `new` vs `malloc()` 初始化情况**

#### **（1）基本类型 `new` 可能不会初始化**

```cpp
int* p1 = new int;   // ❌ 未初始化，值不确定（垃圾值）
int* p2 = new int(); // ✅ 初始化为 0
```

`new int();` **保证初始化为 0**，但 `new int;` **不一定初始化**。

**而 `malloc()` 永远不会初始化：**

```cpp
int* p3 = (int*) malloc(sizeof(int));  // ❌ 未初始化，值不确定
```

---
#### **（2）数组的 `new[]` vs `malloc()`**

**使用 `new[]` 分配数组**

```cpp
int* arr1 = new int[5];   // ❌ 未初始化，可能是垃圾值
int* arr2 = new int[5](); // ✅ 初始化所有元素为 0
```

**使用 `malloc()` 分配数组**

```cpp
int* arr3 = (int*)malloc(5 * sizeof(int)); // ❌ 未初始化
```

**解决方案（使用 `calloc()` 初始化为 0）：**

```cpp
int* arr4 = (int*)calloc(5, sizeof(int));  // ✅ 自动初始化为 0
```

---
### **4. `new[]` vs `malloc()` 释放内存**

|**分配方式**|**释放方式**|
|---|---|
|`new`|`delete`|
|`new[]`|`delete[]`|
|`malloc()`|`free()`|

**⚠️ `new[]` 必须用 `delete[]` 释放，否则会导致未定义行为**

```cpp
int* arr = new int[10];
delete arr;   // ❌ 错误！应该使用 delete[]
delete[] arr; // ✅ 正确
```

---
### **5. `new` 失败时的行为**

**`new` 失败时，抛出 `std::bad_alloc` 异常，而 `malloc()` 失败时返回 `NULL`**：

```cpp
#include <iostream>
#include <cstdlib>

int main() {
    try {
        int* ptr = new int[1000000000000];  // 可能导致内存不足
    } catch (std::bad_alloc& e) {
        std::cout << "Memory allocation failed: " << e.what() << std::endl;
    }

    void* ptr2 = malloc(1000000000000);
    if (!ptr2) {
        std::cout << "malloc failed\n";
    }

    return 0;
}
```

**区别：**

- `new` 失败会抛出 `std::bad_alloc`。
- `malloc()` 失败时，返回 `NULL`，需要手动检查。

---
### **6. `new` 可以重载，但 `malloc()` 不能**

C++ 允许**自定义 `new` 运算符**，但 `malloc()` 是库函数，不能重载：

```cpp
void* operator new(size_t size) {
    std::cout << "Custom new for " << size << " bytes\n";
    return malloc(size);
}

int main() {
    int* p = new int;
    delete p;
    return 0;
}
```

**输出**

```
Custom new for 4 bytes
```

---
### **7. `new` vs `malloc()` 适用场景**

|**使用 `new` 的情况**|**使用 `malloc()` 的情况**|
|---|---|
|**C++ 代码**|**C 代码**|
|需要 **构造/析构函数**|只需要 **分配内存，不调用构造函数**|
|处理 **对象（class）**|处理 **结构体（struct）**|
|可能会用 **异常（`std::bad_alloc`）**|可能会用 **`NULL` 检查**|

---
### **8. 总结**

|**特性**|**`new` / `delete` (C++)**|**`malloc()` / `free()` (C)**|
|---|---|---|
|**是否调用构造/析构函数**|✅ 是|❌ 否|
|**返回类型**|**指定类型指针**，无需转换|`void*`，需**强制转换**|
|**失败处理**|抛出 `std::bad_alloc`|返回 `NULL`|
|**初始化**|类对象调用构造函数，基本类型不初始化（`new int();` 例外）|仅分配内存，不初始化|
|**释放方式**|`delete` / `delete[]`|`free()`|
|**是否可重载**|✅ `operator new()` 可重载|❌ 不能重载|
|**适用场景**|C++ 面向对象编程|C 语言，内存管理|

**🚀 结论**

- `new` **适用于 C++ 面向对象编程**（自动调用构造/析构）。
- `malloc()` **适用于 C 语言**，或 C++ 需要手动内存管理时。
- **C++ 推荐使用 `new`，除非和 `malloc()` 代码兼容（如 `realloc()`）。** 🚀

---
## 讲讲 assert 还有 static_assert 

### **📌 `assert` 和 `static_assert` 的区别**

C++ 提供了两种断言（Assertion）机制：

1. **`assert`（运行时断言）**：在 **运行时** 进行检查，`assert(false)` 触发程序终止。
2. **`static_assert`（编译时断言）**：在 **编译时** 进行检查，若失败则编译报错。

|**类型**|**`assert`**（运行时断言）|**`static_assert`**（编译时断言）|
|---|---|---|
|**检查时间**|运行时（Runtime）|编译时（Compile-time）|
|**失败后果**|程序终止（`abort()`）|编译失败|
|**适用场景**|变量值检查、调试|类型检查、模板编程|
|**头文件**|`<cassert>`|C++11 起的 **内置关键字**|

---
### **1️⃣ `assert`（运行时断言）**

#### **📌 作用**

- **在运行时检查条件**是否成立，不满足时终止程序执行。
- **用于调试**，可以在 `NDEBUG` 宏定义时禁用。

#### **📌 示例**

```cpp
#include <iostream>
#include <cassert>  // 必须包含此头文件

int divide(int a, int b) {
    assert(b != 0);  // 运行时检查，防止除零
    return a / b;
}

int main() {
    int x = 10, y = 0;
    std::cout << divide(x, y) << std::endl;  // ❌ 触发断言失败
    return 0;
}
```

#### **📌 输出（断言失败）：**

```
Assertion failed: (b != 0), function divide
```

**解析**：

- `assert(b != 0)` 用于检查 `b` 是否为 `0`，如果 `b == 0`，程序终止。

#### **📌 `NDEBUG` 影响 `assert`**

如果定义 `NDEBUG`（**No Debug**），`assert()` **会被编译器优化掉**：

```cpp
#define NDEBUG  // 取消所有 assert
#include <cassert>

int main() {
    assert(2 + 2 == 5);  // ❌ 无效果
    return 0;
}
```

✅ **`NDEBUG` 适用于优化**，可在发布（Release）模式中**禁用断言**。

---
### **2️⃣ `static_assert`（编译时断言）**

#### **📌 作用**

- **在编译时检查条件**，如果不满足，**编译失败**。
- **用于模板编程**、类型检查、静态约束等场景。
- **从 C++11 起成为关键字**，无需包含头文件。

#### **📌 示例**

```cpp
#include <iostream>

// 确保 `sizeof(int) == 4`，否则编译失败
static_assert(sizeof(int) == 4, "int size is not 4 bytes!");

template <typename T>
void checkType() {
    static_assert(sizeof(T) >= 4, "Type size must be at least 4 bytes!");
}

int main() {
    checkType<int>();    // ✅ 编译通过
    checkType<char>();   // ❌ 编译失败（char 通常是 1 字节）
    return 0;
}
```

#### **📌 编译失败（错误信息）：**

```
error: static assertion failed: Type size must be at least 4 bytes!
```

**解析**：

- `static_assert(sizeof(int) == 4, "int size is not 4 bytes!");`
    - **在编译时检查** `sizeof(int) == 4` 是否成立。
    - 如果 `int` 不是 **4 字节**，**编译失败**（不同平台可能不同）。
- `checkType<char>();`
    - **`sizeof(char) == 1`**，导致 `static_assert` 失败，编译终止。

---
### **📌 `assert` vs `static_assert` 何时使用？**

|**使用场景**|**使用 `assert`（运行时）**|**使用 `static_assert`（编译时）**|
|---|---|---|
|**调试代码**|✅ 适用于调试（可被 `NDEBUG` 关闭）|❌ 不能用于运行时调试|
|**防止非法操作**|✅ 运行时检查变量值（如除 0）|❌ 不能检查运行时值|
|**类型检查**|❌ 运行时无法检测|✅ 编译期检测|
|**模板编程**|❌ 运行时才知道类型|✅ 适用于泛型|
|**编译优化**|❌ 存在运行时开销|✅ 纯编译期，不影响性能|

**✅ 结论：**

- **`assert` 适用于调试（变量值检查）**，避免非法操作，如 **除零、数组越界**。
- **`static_assert` 适用于模板编程、类型约束**，如 **检查 `sizeof(T)`、类型特性**。
- **发布版（Release）建议移除 `assert`**，但 **`static_assert` 不受影响**（它本就不会产生运行时开销）。

---
### **📌 重点总结**

|**特性**|**`assert`（运行时）**|**`static_assert`（编译时）**|
|---|---|---|
|**检查时间**|运行时（`if` 判断）|编译时|
|**失败后果**|程序终止|编译失败|
|**头文件**|`<cassert>`|无需头文件|
|**影响性能**|**影响（运行时开销）**|**无影响（纯编译时）**|
|**适用场景**|调试，防止非法输入|类型检查，模板编程|

---
### **📌 经典问题** **🚀 `static_assert` 能否替代 `assert`？**

❌ **不能完全替代！**

- **`static_assert` 只能检查** **"编译时可确定的条件"**，如 `sizeof(T) == 4`。
- 但 **运行时变量的检查**（如 `b != 0`）**必须用 `assert`**。

---
### **📌 结论**

- **`assert`** 适用于**运行时调试**，可检查**变量值**，但可被 `NDEBUG` 关闭。
- **`static_assert`** 适用于**编译时约束**，常用于**模板编程、类型检查**，**没有运行时开销**。

**🚀 建议**

1. **运行时检查** → 用 `assert`（调试用，发布版可移除）。
2. **编译时检查** → 用 `static_assert`（泛型编程、类型检查）。

💡 **两者结合使用，可以让 C++ 代码更安全、更高效！** 🚀

---
## 讲讲左值和右值 

### **📌 左值（Lvalue） vs 右值（Rvalue）**

在 C++ 中，**左值（Lvalue）** 和 **右值（Rvalue）** 是与**表达式的存储特性**相关的概念。

|**类型**|**特点**|
|---|---|
|**左值（Lvalue）**|**有持久存储**（可取地址 `&`），可以出现在赋值运算符 `=` 左侧|
|**右值（Rvalue）**|**没有持久存储**（不能取地址 `&`），通常是**字面量**或**临时值**|

---
### **📌 1. 左值（Lvalue）**

#### **✅ 主要特点**

1. **可取地址**（可用于 `&` 运算符）。
2. **可以出现在赋值运算符 = 左侧**。
3. **具有存储空间，生命周期可持续**（变量、数组元素等）。

#### **✅ 示例**

```cpp
int x = 10;  // x 是左值
x = 20;      // ✅ 左值可赋值
std::cout << &x << std::endl;  // ✅ 左值可取地址
```

**左值包括**

|**左值类型**|**示例**|
|---|---|
|**变量**|`int x = 10;`|
|**数组元素**|`arr[0] = 5;`|
|**指针解引用**|`*ptr = 10;`|
|**结构体成员**|`s.a = 5;`|

---
### **📌 2. 右值（Rvalue）**

#### **✅ 主要特点**

1. **不可取地址 `&`**（没有持久存储）。
2. **不能出现在赋值运算符 = 左侧**。
3. **临时值、字面量、表达式计算结果**。

#### **✅ 示例**

```cpp
int y = 5 + 10;  // 5 + 10 是右值
int x = 10;  
x = y + 5;  // y + 5 是右值
10 = x;  // ❌ 错误，10 是右值，不能赋值
```

#### **🚀 右值的典型案例**

|**右值类型**|**示例**|
|---|---|
|**字面量**|`10, 3.14, 'c'`|
|**表达式计算结果**|`x + y, 5 * 3`|
|**函数返回的非引用值**|`int foo() { return 5; }`|

---
### **📌 3. 左值 vs 右值 对比**

|**特性**|**左值（Lvalue）**|**右值（Rvalue）**|
|---|---|---|
|**是否可取地址 `&`**|✅ 可以|❌ 不能|
|**是否能赋值**|✅ 可以|❌ 不能|
|**是否有存储**|✅ 有|❌ 无（临时值）|
|**示例**|`int x = 10;`|`x + 5;`、`10;`|

---
### **📌 4. 右值引用（Rvalue Reference）**

#### **🚀 `int&&` 右值引用**

**C++11 引入了右值引用 `T&&`，专门用于绑定右值，提高性能。**

```cpp
int&& r = 10;  // ✅ 右值引用绑定到右值
```

❌ **不能绑定左值**

```cpp
int x = 10;
int&& r = x;  // ❌ 错误！不能将左值赋给右值引用
```

---
### **📌 5. 右值引用的应用：移动语义**

#### **🚀 `std::move()`**

**右值引用的主要作用是** **避免不必要的拷贝，提高性能**。

```cpp
#include <iostream>
#include <vector>

int main() {
    std::vector<int> v1 = {1, 2, 3};
    std::vector<int> v2 = std::move(v1);  // ✅ 右值引用：v1 的数据被移动到 v2

    std::cout << "v1 size: " << v1.size() << std::endl;  // v1 变为空
    return 0;
}
```

---
### **📌 6. 总结**

|**类型**|**特点**|**示例**|
|---|---|---|
|**左值（Lvalue）**|**有存储，可取地址 `&`，可赋值**|`int x = 10;`|
|**右值（Rvalue）**|**无存储，不能取地址，不能赋值**|`x + 5; 10;`|
|**右值引用（Rvalue Reference）**|**`&&` 绑定右值，支持移动语义**|`int&& r = 10;`|

✅ **左值 = 持久存储的变量**  
✅ **右值 = 临时值，不可取地址**  
✅ **右值引用 `T&&` 用于移动语义，避免拷贝** 🚀

---
## **📌 C++ 移动语义（Move Semantics）**

### **1. 什么是移动语义？**

**移动语义（Move Semantics）** 是 C++11 引入的一种优化机制，允许**在不进行深拷贝的情况下转移资源**，提高程序性能。  
**关键点**：

- 通过 **右值引用 `T&&`** 实现，避免不必要的 **拷贝**，减少资源分配和释放的开销。
- 主要用于 **动态内存管理**（如 `std::vector`、`std::string`）。
- **移动构造函数** 和 **移动赋值运算符** 实现 **资源转移**，而不是拷贝。

---
### **2. 为什么需要移动语义？**

#### **🚀 传统拷贝方式（深拷贝）**

**C++98 及之前，复制对象时会进行深拷贝**：

```cpp
#include <iostream>
#include <vector>

std::vector<int> createVector() {
    return std::vector<int>{1, 2, 3, 4, 5};
}

int main() {
    std::vector<int> v = createVector();  // 传统拷贝
    return 0;
}
```

#### **❌ 问题**

1. `createVector()` 返回 **临时对象**，会触发 **拷贝构造**。
2. **`std::vector<int>` 内部存储大量数据，拷贝成本高**。
3. **移动语义优化**：**避免拷贝**，直接**"移动"** 数据。

---
### **3. 右值引用（`T&&`）—— 移动语义的关键**

- **右值引用 `T&&`** 允许**绑定右值（临时对象）**，从而**移动资源**，避免拷贝。

#### **✅ 右值引用示例**

```cpp
#include <iostream>

int&& getRvalue() {
    return 10;  // ✅ 右值可以绑定到右值引用
}

int main() {
    int&& r = getRvalue();  // r 是右值引用
    std::cout << r << std::endl;  // 输出 10
    return 0;
}
```

**🚀 右值引用特点**

1. `int&& r = getRvalue();` → `r` **绑定到右值**，但 **r 本身是左值**。
2. **右值引用 `T&&` 允许转移资源**，是**移动语义的基础**。

---
### **4. 移动构造函数**

#### **🚀 移动构造 vs 复制构造**

```cpp
class MyClass {
public:
    int* data;

    // 普通构造函数
    MyClass(int val) : data(new int(val)) {
        std::cout << "Constructor\n";
    }

    // ✅ 移动构造函数（接收右值引用）
    MyClass(MyClass&& other) noexcept : data(other.data) {
        other.data = nullptr;  // 资源转移
        std::cout << "Move Constructor\n";
    }

    // ❌ 复制构造（深拷贝）
    MyClass(const MyClass& other) : data(new int(*other.data)) {
        std::cout << "Copy Constructor\n";
    }

    ~MyClass() {
        delete data;
    }
};

int main() {
    MyClass obj1(10);  // 调用普通构造
    MyClass obj2 = std::move(obj1);  // ✅ 触发移动构造
    return 0;
}
```

#### **✅ 运行结果**

```
Constructor
Move Constructor
```

**🚀 `std::move(obj1)` 触发移动构造，避免了 `new` 操作！**

---
### **5. 移动赋值运算符**

#### **🚀 `operator=` 实现移动赋值**

```cpp
class MyClass {
public:
    int* data;

    MyClass(int val) : data(new int(val)) {}

    // ✅ 移动赋值运算符
    MyClass& operator=(MyClass&& other) noexcept {
        if (this != &other) {  // 避免自赋值
            delete data;  // 释放旧资源
            data = other.data;  // 资源转移
            other.data = nullptr;
        }
        std::cout << "Move Assignment\n";
        return *this;
    }

    ~MyClass() { delete data; }
};

int main() {
    MyClass obj1(10);
    MyClass obj2(20);
    obj2 = std::move(obj1);  // ✅ 触发移动赋值
    return 0;
}
```

**✅ 运行结果**

```
Move Assignment
```

**🚀 解析**

- `std::move(obj1)` **强制转换 obj1 为右值**，触发移动赋值。
- 释放 `obj2` 旧数据，转移 `obj1` 的资源，并置空 `obj1.data` 避免重复释放。

---
### **6. `std::move()`**

**`std::move(obj)` 并不移动数据，它只是** **将左值转换为右值**，从而触发**移动构造或移动赋值**。

```cpp
#include <iostream>
#include <vector>

int main() {
    std::vector<int> v1 = {1, 2, 3};
    std::vector<int> v2 = std::move(v1);  // ✅ 触发移动构造
    std::cout << "v1 size: " << v1.size() << std::endl;  // v1 为空
    return 0;
}
```

**✅ 运行结果**

```
v1 size: 0
```

**🚀 `std::move(v1)`**

- 让 `v2` **直接接管 `v1` 的数据**，而**不拷贝**数据。
- `v1.size()` 变为 `0`，但 `v1` 仍然有效（只是内部数据指针已转移）。

---
### **7. 什么时候使用移动语义？**

|**场景**|**推荐做法**|
|---|---|
|**大对象（`std::vector`, `std::string`）**|✅ **使用移动构造**|
|**对象返回值优化（RVO）**|✅ **`return std::move(obj);`**|
|**避免不必要的拷贝**|✅ **`std::move()`**|
|**使用 `std::unique_ptr`**|✅ **移动代替拷贝**|

---
### **8. 传统拷贝 vs 移动语义**

|**方式**|**开销**|**是否调用构造/析构**|
|---|---|---|
|**拷贝构造**|**高**（创建新对象+拷贝数据）|✅ 调用构造 & 复制|
|**移动构造**|**低**（仅指针转移）|✅ 仅转移资源|

**🚀 总结**

- **拷贝构造：适用于不可修改的对象（如 `const`）。**
- **移动构造：适用于可转移的对象，提高性能。**

---
### **9. 重点总结**

|**特性**|**拷贝语义（C++98）**|**移动语义（C++11）**|
|---|---|---|
|**关键字**|`T&`|`T&&`|
|**拷贝构造**|`T(const T&)`|`T(T&&)`|
|**拷贝赋值**|`T& operator=(const T&)`|`T& operator=(T&&)`|
|**性能**|**慢（深拷贝）**|**快（资源转移）**|
|**适用场景**|需要完整拷贝数据|仅转移资源|

---
### **📌 结论**

- **C++11 引入移动语义，减少深拷贝，提高性能。**
- **使用 `std::move()` 触发移动构造和移动赋值。**
- **大对象（如 `std::vector`、`std::string`）应使用移动语义，减少内存开销。**
- **编写 C++ 高效代码时，优先使用 `std::move()` 进行优化！** 🚀

---
## const T & 可以接受右值吗？ 

### **📌 `const T&` 能否接受右值？**

#### **✅ 答案：`const T&` 可以接受右值**

**`const T&` 既可以绑定到左值，也可以绑定到右值**。  
但是，**普通的 `T&`（非 `const`）只能绑定到左值**，而不能绑定右值。

---
### **1️⃣ `const T&` 绑定左值**

```cpp
int x = 10;
const int& ref = x;  // ✅ 绑定左值
```

- `x` 是 **左值**，可以绑定到 `const int& ref`。

---
### **2️⃣ `const T&` 绑定右值**

```cpp
const int& ref = 10;  // ✅ 绑定右值
std::cout << ref << std::endl;  // 输出 10
```

- `10` 是 **右值**（临时值），但 `const int&` **可以绑定到右值**。
- **右值会延长生命周期**，直到 `ref` 作用域结束。

**🚀 为什么 `const T&` 能绑定右值？**

- **右值本身不可修改**，而 `const T&` 也是 **只读**。
- **编译器优化**：创建**一个临时变量**，存储右值。

---
### **3️⃣ `T&`（非 `const` 引用）不能绑定右值**

```cpp
int& ref = 10;  // ❌ 错误！普通引用不能绑定右值
```

❌ **编译错误**

```
error: cannot bind non-const lvalue reference to an rvalue
```

- 右值是临时值，没有存储位置，普通 `T&` 不能绑定它。

✅ **解决方案：使用 `const T&` 或 `T&&`（右值引用）**

```cpp
const int& ref1 = 10;  // ✅ 允许（只读引用）
int&& ref2 = 10;  // ✅ 允许（右值引用）
```

---
### **4️⃣ `const T&` 延长右值生命周期**

- **当 `const T&` 绑定右值时，右值的生命周期会被延长，直到 `const T&` 作用域结束**。

```cpp
#include <iostream>

const std::string& getString() {
    return "Hello";  // ❌ 错误！返回临时右值的引用
}

int main() {
    const std::string& ref = std::string("Hello");  // ✅ 右值生命周期延长
    std::cout << ref << std::endl;
    return 0;
}
```

✅ **编译成功，输出 "Hello"**

- **`ref` 绑定临时 `std::string("Hello")`，生命周期延长**，直到 `ref` 作用域结束。

---
### **5️⃣ `T&&`（右值引用） vs `const T&`**

| **类型**     | **可绑定**     | **是否可修改** | **主要用途** |
| ---------- | ----------- | --------- | -------- |
| `T&`       | 仅**左值**     | ✅ 可修改     | 变量传递     |
| `const T&` | **左值 + 右值** | ❌ 只读      | 只读访问     |
| `T&&`      | 仅**右值**     | ✅ 可修改     | 移动语义     |

#### **✅ 右值引用 `T&&` 用于移动语义**

```cpp
void process(std::string&& str) {  // 仅接受右值
    std::cout << str << std::endl;
}
process(std::string("Hello"));  // ✅ 右值可传递
process("World");  // ✅ 字符串字面量转换成 std::string 右值
```

---
### **📌 结论**

✅ **`const T&` 可以绑定左值和右值**，且**右值的生命周期会延长**。  
✅ **普通 `T&` 只能绑定左值**，不能绑定右值。  
✅ **右值引用 `T&&` 只能绑定右值**，用于**移动语义**（避免拷贝）。  
💡 **如果不需要修改变量，优先使用 `const T&` 作为参数**，避免不必要的拷贝！ 🚀

---
## 四种智能指针 

C++ 提供了 **四种智能指针**，它们在 **`<memory>` 头文件** 中定义，用于 **自动管理动态内存**，避免内存泄漏。

| **智能指针**                      | **主要特点**                     | **生命周期**                    | **适用场景**                   |
| ----------------------------- | ---------------------------- | --------------------------- | -------------------------- |
| `std::unique_ptr<T>`          | **独占所有权**（不可拷贝）              | **作用域结束或 `reset()`** 自动释放   | 资源独占，动态对象管理                |
| `std::shared_ptr<T>`          | **共享所有权**（引用计数）              | **最后一个 `shared_ptr` 释放时销毁** | 共享资源管理                     |
| `std::weak_ptr<T>`            | **弱引用（不影响 `shared_ptr` 计数）** | **被 `shared_ptr` 控制**       | 避免循环引用                     |
| `std::auto_ptr<T>`（C++98，已弃用） | 旧版 `unique_ptr`，**移动语义**     | **作用域结束释放**                 | **已废弃，使用 `unique_ptr` 代替** |

### **1️⃣ `std::unique_ptr`（独占所有权）**

#### **✅ 主要特点**

- **独占所有权**，即**同一时间只能有一个 `unique_ptr` 指向对象**。
- **不能拷贝**，但**可以通过 `std::move()` 转移所有权**。
- 在**超出作用域时自动释放资源**（无需 `delete`）。

#### **🚀 示例**

```cpp
#include <iostream>
#include <memory>

class Test {
public:
    Test() { std::cout << "Constructor\n"; }
    ~Test() { std::cout << "Destructor\n"; }
};

int main() {
    std::unique_ptr<Test> ptr1 = std::make_unique<Test>();  // ✅ 推荐：创建智能指针
    // std::unique_ptr<Test> ptr2 = ptr1;  // ❌ 错误！`unique_ptr` 不能拷贝
    std::unique_ptr<Test> ptr2 = std::move(ptr1);  // ✅ 转移所有权

    if (!ptr1) std::cout << "ptr1 is nullptr\n";  // ✅ ptr1 被置为空
    return 0;
}
```

#### **✅ 适用场景**

- 需要**独占资源**，如文件、数据库连接、线程管理等。

### **2️⃣ `std::shared_ptr`（共享所有权）**

#### **✅ 主要特点**

- **多个 `shared_ptr` 可以共享同一个对象**，采用**引用计数**管理。
- **引用计数为 `0` 时，对象自动销毁**。
- **线程安全（但 `use_count()` 不是原子操作）**。

#### **🚀 示例**

```cpp
#include <iostream>
#include <memory>

class Test {
public:
    Test() { std::cout << "Constructor\n"; }
    ~Test() { std::cout << "Destructor\n"; }
};

int main() {
    std::shared_ptr<Test> ptr1 = std::make_shared<Test>();  // ✅ 推荐方式
    std::shared_ptr<Test> ptr2 = ptr1;  // ✅ 引用计数 +1

    std::cout << "Use count: " << ptr1.use_count() << std::endl;  // 输出 2

    ptr1.reset();  // ✅ ptr1 释放，但 ptr2 仍持有对象
    std::cout << "Use count: " << ptr2.use_count() << std::endl;  // 输出 1

    return 0;  // 最后 `ptr2` 超出作用域，对象销毁
}
```

#### **✅ 适用场景**

- 需要**多个对象共享资源**，如**缓存、引用计数的内存管理**。

### **3️⃣ `std::weak_ptr`（弱引用）**

#### **✅ 主要特点**

- **不会增加 `shared_ptr` 的引用计数**，避免**循环引用**问题。
- **不能直接访问对象**，需使用 `.lock()` 获取 `shared_ptr`。
- 适用于**观察者模式（Observer Pattern）**。

#### **🚀 避免循环引用**

```cpp
#include <iostream>
#include <memory>

class B;  // 前置声明

class A {
public:
    std::shared_ptr<B> ptrB;
    ~A() { std::cout << "A Destructor\n"; }
};

class B {
public:
    std::weak_ptr<A> ptrA;  // ✅ 使用 `weak_ptr` 避免循环引用
    ~B() { std::cout << "B Destructor\n"; }
};

int main() {
    auto a = std::make_shared<A>();
    auto b = std::make_shared<B>();

    a->ptrB = b;
    b->ptrA = a;  // ✅ 使用 `weak_ptr`，不会增加引用计数

    return 0;  // ✅ `A` 和 `B` 都能正确析构
}
```

#### **✅ 适用场景**

- **避免 `shared_ptr` 循环引用**（如双向关联的对象）。
- **缓存管理**（对象可能被 `shared_ptr` 拿走）。

### **4️⃣ `std::auto_ptr`（已废弃，不推荐使用）**

#### **❌ 主要特点**

- **已在 C++11 被 `unique_ptr` 取代**，C++17 彻底移除。
- **有所有权转移**，但**容易导致悬空指针**，不安全。

#### **🚀 示例（不推荐使用）**

```cpp
#include <iostream>
#include <memory>

int main() {
    std::auto_ptr<int> p1(new int(10));  // ❌ C++11 之后废弃
    std::auto_ptr<int> p2 = p1;  // ✅ p1 变为空
    return 0;
}
```

**✅ 解决方案**

```cpp
std::unique_ptr<int> p1 = std::make_unique<int>(10);  // ✅ 推荐
```

### **5️⃣ 智能指针对比**

|**特性**|`std::unique_ptr`|`std::shared_ptr`|`std::weak_ptr`|`std::auto_ptr` (已废弃)|
|---|---|---|---|---|
|**所有权**|**独占**|**共享**|**弱引用**|**独占（转移）**|
|**可拷贝**|❌ 不可拷贝（`std::move()` 可转移）|✅ 可拷贝|❌ 只能赋值 `shared_ptr`|✅ 但赋值后原指针失效|
|**引用计数**|❌ 无|✅ 有|✅ 有，但不增加|❌ 无|
|**循环引用**|✅ 不会发生|❌ 可能发生|✅ 解决循环引用|❌ 无|
|**适用场景**|资源独占|共享资源|避免循环引用|**已废弃**|

### **6️⃣ 何时使用哪种智能指针？**

|**使用场景**|**推荐智能指针**|**理由**|
|---|---|---|
|资源独占（文件、数据库连接）|`std::unique_ptr`|不允许多个对象管理资源|
|共享资源（引用计数）|`std::shared_ptr`|允许多个对象共享资源|
|解决 `shared_ptr` 循环引用|`std::weak_ptr`|避免循环引用导致的内存泄漏|
|仅 C++98 代码（不推荐）|`std::auto_ptr`|C++11 及之后已废弃|

### **📌 重点总结**

- ✅ **`std::unique_ptr`（独占）**：不允许拷贝，适用于独占资源。
- ✅ **`std::shared_ptr`（共享）**：支持多个 `shared_ptr` 管理同一对象，引用计数。
- ✅ **`std::weak_ptr`（弱引用）**：避免 `shared_ptr` 循环引用问题。
- ❌ **`std::auto_ptr`（已废弃）**：应使用 `unique_ptr` 代替。

💡 **推荐做法**

- **优先使用 `std::unique_ptr`，只有当需要共享资源时才使用 `std::shared_ptr`。**
- **如果 `shared_ptr` 可能形成循环引用，使用 `std::weak_ptr` 解决。**
- **使用 `std::make_unique<T>()` 和 `std::make_shared<T>()` 避免 `new`。**

🚀 **C++ 智能指针让内存管理更安全、更高效，避免手动 `new/delete`！** 🔥

---
## 如何不借助库函数判断大小端（Big-endian vs Little-endian）

**大小端（Endianness）** 决定了多字节数据在内存中的存储方式：
- **小端（Little-endian）**：低字节存储在**低地址**，高字节存储在**高地址**。（Intel x86 体系）
- **大端（Big-endian）**：高字节存储在**低地址**，低字节存储在**高地址**。（Motorola, PowerPC）

### **✅ 方法 1：使用 `union` 判断**

利用 `union` 共用内存的特性，让 `int` 和 `char` 共享存储空间：

```cpp
#include <iostream>

union EndianTest {
    int value;
    char bytes[4];
};

int main() {
    EndianTest test;
    test.value = 0x12345678;  // 存储一个 4 字节整数

    if (test.bytes[0] == 0x78) {
        std::cout << "Little-endian\n";  // 低字节在低地址
    } else {
        std::cout << "Big-endian\n";  // 高字节在低地址
    }
    return 0;
}
```

#### **📝 解析**

- `test.value = 0x12345678;`
- **小端存储**（低字节在低地址）：
    
    ```
    内存地址 → 低地址 ... 高地址
    数据存储 → 78 56 34 12  （Little-endian）
    ```
    
- **大端存储**（高字节在低地址）：
    
    ```
    内存地址 → 低地址 ... 高地址
    数据存储 → 12 34 56 78  （Big-endian）
    ```

✅ **优势：结构清晰，易读易懂**

### **✅ 方法 2：使用 `char*` 指针判断**

```cpp
#include <iostream>

int main() {
    int num = 0x12345678;
    char* ptr = (char*)&num;

    if (*ptr == 0x78) {
        std::cout << "Little-endian\n";
    } else {
        std::cout << "Big-endian\n";
    }
    return 0;
}
```

#### **📝 解析**

- `char* ptr = (char*)&num;` 让 `ptr` 指向 `num` 的最低地址。
- 如果 `*ptr == 0x78`，说明低字节在低地址，**是小端**。

✅ **优势：代码简洁，易于理解**

### **✅ 方法 3：位运算**

```cpp
#include <iostream>

bool isLittleEndian() {
    int num = 1;
    return (*(char*)&num == 1);  // 判断最低字节是否为 1
}

int main() {
    if (isLittleEndian()) {
        std::cout << "Little-endian\n";
    } else {
        std::cout << "Big-endian\n";
    }
    return 0;
}
```

#### **📝 解析**

- `int num = 1;` 在内存中的存储：
    - 小端：`01 00 00 00`
    - 大端：`00 00 00 01`
- `*(char*)&num == 1` 说明**最低字节是 `1`，表示小端**。

✅ **优势：通用性强，适用于任何整数**

### **✅ 方法 4：通过 `std::cout` 观察字节顺序**

```cpp
#include <iostream>

void printBytes(int num) {
    unsigned char* bytes = reinterpret_cast<unsigned char*>(&num);
    for (size_t i = 0; i < sizeof(int); i++) {
        std::cout << std::hex << (int)bytes[i] << " ";
    }
    std::cout << std::endl;
}

int main() {
    int num = 0x12345678;
    printBytes(num);
    return 0;
}
```

#### **📝 解析**

- **小端输出**（Intel x86）：`78 56 34 12`
- **大端输出**（PowerPC）：`12 34 56 78`

✅ **优势：直观可视化数据存储顺序**

### **✅ 方法 5：位移 & 按位与**

```cpp
#include <iostream>

bool isLittleEndian() {
    int num = 0x12345678;
    return ((num & 0xFF) == 0x78);  // 检查最低字节
}

int main() {
    if (isLittleEndian()) {
        std::cout << "Little-endian\n";
    } else {
        std::cout << "Big-endian\n";
    }
    return 0;
}
```

#### **📝 解析**

- `num & 0xFF` 提取最低字节：
    - **小端存储**：`0x78`
    - **大端存储**：`0x12` ✅ **优势：纯数学计算，避免类型转换**

```CPP
#include <iostream>

int getCPUEndianness() {
    unsigned int x = 1; // 0x0000...0001
    char *c = (char*)&x;
    return (int)*c;
}

int main() {
    int endianness = getCPUEndianness();
    if (endianness) {
        std::cout << "CPU是小端模式\n" << std::endl;
    } else {
        std::cout << "CPU是大端模式\n" << std::endl;
    }
    return 0;
}
```

### **📌 总结**

|**方法**|**优点**|**缺点**|
|---|---|---|
|**`union` 方式**|代码清晰，结构直观|依赖 `union`|
|**`char*` 指针方式**|代码简单|可能被优化器影响|
|**位运算**|纯数学操作，通用性强|逻辑稍复杂|
|**字节打印**|结果直观|需要额外输出|
|**位移&按位与**|计算简单|可读性稍差|

### **📌 结论**

✅ **推荐方法**

1. **最直观的方法** → `union` 方法
2. **最简单的方法** → `char*` 指针方法
3. **最可靠的方法** → 位运算方法（适用于跨平台检测）

🚀 **如果不借助库函数，推荐使用 `char*` 或 `union` 进行大小端检测！**

---
## 哪些场景下我们需要注意大小端？

### **📌 需要注意大小端（Endianness）的场景**

在大多数情况下，**程序员不需要关心大小端**，因为现代 CPU 和操作系统会自动处理。但是，在以下 **低级编程、跨平台开发和二进制数据处理** 场景中，大小端问题需要特别注意。

---
### **1️⃣ 网络通信（TCP/IP 协议）**

#### **🚀 场景**

- **不同计算机架构（大小端不同）之间的数据传输**。
- **网络字节序（Big-endian） vs 主机字节序（CPU 可能是小端）**。
- **跨平台数据通信（ARM, x86, PowerPC）**。

#### **✅ 解决方案**

**网络协议（TCP/IP）采用大端字节序（Big-endian）**：

- 发送数据时，**主机字节序转换为网络字节序（`htonl()` / `htons()`）**。
- 接收数据时，**网络字节序转换为主机字节序（`ntohl()` / `ntohs()`）**。

#### **📌 示例**

```cpp
#include <iostream>
#include <arpa/inet.h>  // htonl, htons, ntohl, ntohs

int main() {
    uint32_t hostValue = 0x12345678;
    uint32_t networkValue = htonl(hostValue);  // 转换为大端（网络字节序）

    std::cout << "Host: 0x" << std::hex << hostValue << std::endl;
    std::cout << "Network: 0x" << std::hex << networkValue << std::endl;

    return 0;
}
```

**📝 解释**

- `htonl()`（Host to Network Long）确保**不同 CPU 平台发送的数据格式一致**。
- `ntohl()`（Network to Host Long）接收数据后转换回主机字节序。

---
### **2️⃣ 文件存储（序列化 & 反序列化）**

#### **🚀 场景**

- **二进制文件存储**：不同 CPU 读取同一个文件，数据格式可能不兼容。
- **跨平台文件格式**（如 BMP, PNG, WAV, ZIP）。
- **操作系统日志、数据库存储格式**（如 SQLite）。

#### **✅ 解决方案**

- **存储前转换为固定字节序（通常是大端）**。
- **读取时检测字节序并转换**。

#### **📌 示例**

```cpp
#include <iostream>
#include <fstream>

void writeFile(const char* filename, uint32_t value) {
    std::ofstream file(filename, std::ios::binary);
    uint32_t bigEndianValue = htonl(value);
    file.write(reinterpret_cast<char*>(&bigEndianValue), sizeof(bigEndianValue));
    file.close();
}

uint32_t readFile(const char* filename) {
    std::ifstream file(filename, std::ios::binary);
    uint32_t value;
    file.read(reinterpret_cast<char*>(&value), sizeof(value));
    file.close();
    return ntohl(value);  // 读取后转换为主机字节序
}

int main() {
    const char* filename = "data.bin";
    writeFile(filename, 0x12345678);
    uint32_t value = readFile(filename);
    std::cout << "Read value: 0x" << std::hex << value << std::endl;
    return 0;
}
```

✅ **二进制文件始终存储为大端格式，确保跨平台兼容性**。

---

### **3️⃣ 嵌入式系统（ARM, DSP, FPGA）**

#### **🚀 场景**

- **ARM 处理器可能支持大端和小端模式**，但 x86 仅支持小端。
- **与外设（I²C, SPI, UART）通信时，数据格式可能固定**。
- **DSP、FPGA 可能使用特定字节序，与主机 CPU 交换数据时要转换**。

#### **✅ 解决方案**

- **检查 CPU 的大小端模式（如 `__BYTE_ORDER__` 宏）**。
- **手动字节序转换（`htonl()` / `ntohl()` 或手写转换）**。

#### **📌 手动字节序转换**

```cpp
uint32_t swapEndian(uint32_t value) {
    return ((value >> 24) & 0x000000FF) |
           ((value >> 8)  & 0x0000FF00) |
           ((value << 8)  & 0x00FF0000) |
           ((value << 24) & 0xFF000000);
}
```

✅ **在大小端不同的嵌入式设备间传输数据时使用**。

---
### **4️⃣ 加密 & 压缩（AES, DES, GZIP, ZIP）**

#### **🚀 场景**

- **加密算法（如 AES, DES）使用固定字节序**，不同 CPU 可能不兼容。
- **压缩文件格式（ZIP, GZIP）规定了固定的大小端格式**。
- **哈希算法（MD5, SHA-256）可能需要标准化输入数据的字节序**。

#### **✅ 解决方案**

- **在计算前确保输入数据字节序一致**。
- **使用标准库提供的字节序转换函数**。

---
### **5️⃣ 共享内存（多进程 & 进程间通信 IPC）**

#### **🚀 场景**

- **不同架构的 CPU 进程共享内存时，数据的字节序可能不同**。
- **进程间通信（IPC）可能涉及不同字节序的数据交换**。

#### **✅ 解决方案**

- **使用固定字节序存储数据**，如 `htonl()` / `ntohl()` 。
- **在读取数据时根据 CPU 字节序转换**。

---
### **6️⃣ 反向工程 & 逆向分析**

#### **🚀 场景**

- **分析二进制文件（ELF, PE, Mach-O）** 时，需要正确解析结构体字段的字节序。
- **分析游戏存档文件**，大小端不同会影响解析正确性。
- **调试和内存分析（GDB, IDA Pro）** 时，手动检查数据字节序。

#### **✅ 解决方案**

- **使用 `xxd`、`hexdump` 或 `gdb` 查看数据的字节序**。
- **根据 CPU 平台调整解析方式**。

---
### **📌 重点总结**

|**场景**|**问题**|**解决方案**|
|---|---|---|
|**网络通信（TCP/IP）**|发送数据大小端不匹配|`htonl()` / `ntohl()`|
|**文件存储（序列化）**|不同 CPU 读取数据格式不同|固定字节序（通常大端）|
|**嵌入式系统（ARM）**|设备可能使用大端或小端|手动转换或 `__BYTE_ORDER__` 宏|
|**加密 & 压缩**|数据输入字节序不匹配|确保标准格式（如 AES, ZIP）|
|**共享内存（IPC）**|多进程数据交换|统一字节序格式|
|**逆向工程 & 反向分析**|解析二进制文件|确定目标平台字节序|

✅ **在多平台、多设备、多进程通信、二进制文件处理等场景中，大小端问题不可忽视**！  
✅ **C++ 提供 `htonl()` / `ntohl()`，嵌入式环境可用 `__BYTE_ORDER__` 宏**。  
✅ **最安全的做法：固定使用 "大端" 存储，使用转换函数确保正确读取**。 🚀

---
## 讲讲常用的排序算法的复杂度和稳定性 

### **📌 常用排序算法的时间复杂度 & 稳定性**

排序算法是计算机基础算法之一，主要关注：

1. **时间复杂度**（最好、最坏、平均情况）
2. **空间复杂度**（是否原地排序）
3. **稳定性**（相同值的元素排序后相对位置是否保持）

---
### **1️⃣ 冒泡排序（Bubble Sort）**

#### **✅ 介绍**

- 通过**相邻元素交换**，将**最大/最小元素逐步“冒泡”**到正确位置。
- 适用于**小规模数据**，但**效率低**。

#### **🚀 复杂度**

|**最佳情况（已排序）**|**最坏情况（逆序）**|**平均情况**|**空间复杂度**|**稳定性**|
|---|---|---|---|---|
|**O(n)**|**O(n²)**|**O(n²)**|**O(1)（原地排序）**|**稳定**|

#### **📌 示例代码**

```cpp
void bubbleSort(int arr[], int n) {
    for (int i = 0; i < n - 1; i++) {
        for (int j = 0; j < n - 1 - i; j++) {
            if (arr[j] > arr[j + 1]) std::swap(arr[j], arr[j + 1]);
        }
    }
}
```

#### **✅ 适用场景**

- **数据规模小（`n < 1000`）**
- **基本有序的数据**

---
### **2️⃣ 选择排序（Selection Sort）**

#### **✅ 介绍**

- **每轮从未排序部分选出最小/最大值，放到正确位置**。
- **不稳定排序**（相同元素可能因交换位置改变顺序）。

#### **🚀 复杂度**

|**最佳情况**|**最坏情况**|**平均情况**|**空间复杂度**|**稳定性**|
|---|---|---|---|---|
|**O(n²)**|**O(n²)**|**O(n²)**|**O(1)（原地排序）**|**不稳定**|

#### **📌 示例代码**

```cpp
void selectionSort(int arr[], int n) {
    for (int i = 0; i < n - 1; i++) {
        int minIndex = i;
        for (int j = i + 1; j < n; j++) {
            if (arr[j] < arr[minIndex]) minIndex = j;
        }
        std::swap(arr[i], arr[minIndex]);
    }
}
```

#### **✅ 适用场景**

- **内存写入操作较少时（减少交换次数）**
- **数据规模较小**

---
### **3️⃣ 插入排序（Insertion Sort）**

#### **✅ 介绍**

- **将元素逐个插入到已排序序列中**。
- **稳定排序**，适用于**少量数据或近乎有序数据**。

#### **🚀 复杂度**

|**最佳情况（已排序）**|**最坏情况（逆序）**|**平均情况**|**空间复杂度**|**稳定性**|
|---|---|---|---|---|
|**O(n)**|**O(n²)**|**O(n²)**|**O(1)（原地排序）**|**稳定**|

#### **📌 示例代码**

```cpp
void insertionSort(int arr[], int n) {
    for (int i = 1; i < n; i++) {
        int key = arr[i], j = i - 1;
        while (j >= 0 && arr[j] > key) {
            arr[j + 1] = arr[j];
            j--;
        }
        arr[j + 1] = key;
    }
}
```

#### **✅ 适用场景**

- **小规模数据（`n < 1000`）**
- **数据基本有序**

---
### **4️⃣ 归并排序（Merge Sort）**

#### **✅ 介绍**

- **分治法**，递归将数组分为两半，再合并排序好的子数组。
- **稳定排序**，适用于**大规模数据排序**。

#### **🚀 复杂度**

|**最佳情况**|**最坏情况**|**平均情况**|**空间复杂度**|**稳定性**|
|---|---|---|---|---|
|**O(n log n)**|**O(n log n)**|**O(n log n)**|**O(n)（非原地排序）**|**稳定**|

#### **📌 示例代码**

```cpp
void merge(int arr[], int left, int mid, int right) {
    int n1 = mid - left + 1, n2 = right - mid;
    int L[n1], R[n2];

    for (int i = 0; i < n1; i++) L[i] = arr[left + i];
    for (int i = 0; i < n2; i++) R[i] = arr[mid + 1 + i];

    int i = 0, j = 0, k = left;
    while (i < n1 && j < n2) arr[k++] = (L[i] <= R[j]) ? L[i++] : R[j++];
    while (i < n1) arr[k++] = L[i++];
    while (j < n2) arr[k++] = R[j++];
}

void mergeSort(int arr[], int left, int right) {
    if (left < right) {
        int mid = left + (right - left) / 2;
        mergeSort(arr, left, mid);
        mergeSort(arr, mid + 1, right);
        merge(arr, left, mid, right);
    }
}
```

#### **✅ 适用场景**

- **大规模数据**
- **需要稳定排序**

---
### **5️⃣ 快速排序（Quick Sort）**

#### **✅ 介绍**

- **分治法**，选取**基准值（pivot）**，将小于基准的放左侧，大于的放右侧，递归排序。
- **高效排序**，但**最坏情况下（已排序数据）退化为 $O(n²)$**。
- **当数组为顺序或逆序时,即每次选的 key 都是最小或最大时**，快排会退化成 $O(n^2)$

#### **🚀 复杂度**

| **最佳情况**       | **最坏情况**         | **平均情况**       | **空间复杂度**         | **稳定性** |
| -------------- | ---------------- | -------------- | ----------------- | ------- |
| **O(n log n)** | **O(n²)（已排序情况）** | **O(n log n)** | **O(log n)（递归栈）** | **不稳定** |

#### **📌 示例代码**

```cpp
int partition(int arr[], int low, int high) {
    int pivot = arr[high], i = low - 1;
    for (int j = low; j < high; j++) {
        if (arr[j] < pivot) std::swap(arr[++i], arr[j]);
    }
    std::swap(arr[i + 1], arr[high]);
    return i + 1;
}

void quickSort(int arr[], int low, int high) {
    if (low < high) {
        int pi = partition(arr, low, high);
        quickSort(arr, low, pi - 1);
        quickSort(arr, pi + 1, high);
    }
}
```

#### **✅ 适用场景**

- **数据无序且规模较大**
- **不要求稳定性**

---

### **📌 排序算法对比总结**

|**算法**|**时间复杂度（平均）**|**空间复杂度**|**稳定性**|**适用场景**|
|---|---|---|---|---|
|**冒泡排序**|O(n²)|O(1)|✅ 稳定|小数据量，几乎有序|
|**选择排序**|O(n²)|O(1)|❌ 不稳定|需要减少交换次数|
|**插入排序**|O(n²)|O(1)|✅ 稳定|小规模或基本有序|
|**归并排序**|O(n log n)|O(n)|✅ 稳定|大规模数据，稳定排序|
|**快速排序**|O(n log n)|O(log n)|❌ 不稳定|无序大数据，快速排序|

🚀 **推荐**

- **大数据无序排序**：**快速排序**
- **稳定排序**：**归并排序**
- **小数据量**：**插入排序**

---

## std::sort 的代码看过吗，是怎么实现的？ 

### **📌 `std::sort` 是如何实现的？**

`std::sort` 是 C++ 标准库提供的**高效排序算法**，位于 `<algorithm>` 头文件中。  
**它的底层实现通常是 "introsort"（内省排序）**，结合了：

- **快速排序（QuickSort）**
- **堆排序（HeapSort）**
- **插入排序（InsertionSort）**

🚀 **核心思想**：

1. **快排优先**：初始使用快速排序，快速分区，平均时间复杂度 `O(n log n)`。
2. **递归深度过深时切换为堆排**：防止快速排序在**最坏情况下退化为 `O(n²)`**。
3. **小区间使用插入排序**：当数据量 `n < 16` 时，**插入排序比快排更高效**。

---
### **1️⃣ `std::sort` 代码实现（GCC 版本）**

### **🚀 源码结构**

```cpp
template <class RandomIt>
void sort(RandomIt first, RandomIt last) {
    if (first == last) return;  // 空数组不排序
    __introsort_loop(first, last, 2 * log(last - first));  // 内省排序
    __insertion_sort(first, last);  // 小规模数组用插入排序
}
```

#### **🚀 详细步骤**

1. **`__introsort_loop()`：先用快速排序**
    
    ```cpp
    template <class RandomIt, class Size>
    void __introsort_loop(RandomIt first, RandomIt last, Size depth_limit) {
        while (last - first > 16) {  // 递归到小数组时停止
            if (depth_limit == 0) {  // 递归太深，改用堆排序
                __heap_sort(first, last);
                return;
            }
            --depth_limit;
            RandomIt pivot = __partition(first, last);  // 快排分区
            __introsort_loop(pivot, last, depth_limit);  // 递归处理右侧
            last = pivot;  // 继续处理左侧（避免递归栈过深）
        }
    }
    ```
    
    **🔹 逻辑解析**
    - `last - first > 16`：大于 `16` 个元素时，继续快排。
    - `depth_limit == 0`：如果递归太深（`log(n)` 级别），则改用堆排序，防止最坏情况 `O(n²)` 退化。
    - `__partition()`：快速排序的分区过程（Hoare's partition scheme）。

---

2. **`__heap_sort()`：递归深度太大时改用堆排序**
    
    ```cpp
    template <class RandomIt>
    void __heap_sort(RandomIt first, RandomIt last) {
        std::make_heap(first, last);  // 建立最大堆
        std::sort_heap(first, last);  // 堆排序
    }
    ```
    
    **🔹 逻辑解析**
    - 先使用 `std::make_heap()` 构建最大堆 `O(n)`。
    - 再用 `std::sort_heap()` 进行 `O(n log n)` 的排序。

---

3. **`__partition()`：快速排序的分区过程**
    
    ```cpp
    template <class RandomIt>
    RandomIt __partition(RandomIt first, RandomIt last) {
        RandomIt pivot = first + (last - first) / 2;  // 选取中间元素
        std::iter_swap(pivot, last - 1);  // 把 pivot 放到最后
        RandomIt i = first, j = last - 1;
        while (i < j) {
            while (*i < *(last - 1)) ++i;  // 找到左侧比 pivot 大的
            while (*j > *(last - 1)) --j;  // 找到右侧比 pivot 小的
            if (i < j) std::iter_swap(i++, j--);
        }
        std::iter_swap(i, last - 1);  // 还原 pivot
        return i;
    }
    ```
    
    **🔹 逻辑解析**
    - **选取中间值作为 `pivot`**（避免已排序数据退化）。
    - **左右双指针逼近法**，将小于 `pivot` 的值放左侧，大于 `pivot` 的放右侧。
    - **最终 `pivot` 归位**，返回 `pivot` 位置，便于递归快排。

---

4. **`__insertion_sort()`：小数组用插入排序**
    
    ```cpp
    template <class RandomIt>
    void __insertion_sort(RandomIt first, RandomIt last) {
        for (RandomIt i = first + 1; i != last; ++i) {
            for (RandomIt j = i; j > first && *j < *(j - 1); --j) {
                std::iter_swap(j, j - 1);
            }
        }
    }
    ```
    
    **🔹 逻辑解析**
    - **小数组（`n < 16`）时，插入排序比快排快**（数据局部性好）。
    - **逐个插入排序，适用于小规模数据集**。

---
### **2️⃣ `std::sort` 的时间复杂度**

|**算法阶段**|**时间复杂度**|**最坏情况**|
|---|---|---|
|**快速排序（默认）**|`O(n log n)`|`O(n²)`（已排序数组）|
|**堆排序（最坏情况触发）**|`O(n log n)`|`O(n log n)`|
|**插入排序（小规模 `n < 16`）**|`O(n²)`|`O(n²)`|

✅ **最终 `std::sort` 的时间复杂度是 `O(n log n)`（综合快排 + 堆排 + 插排）**。

---
### **3️⃣ `std::sort` vs `qsort`（C 语言 `qsort()`）**

|**特性**|**`std::sort`（C++）**|**`qsort()`（C）**|
|---|---|---|
|**底层实现**|内省排序（introsort）|纯快速排序|
|**性能**|`O(n log n)`，最坏 `O(n log n)`|可能退化 `O(n²)`|
|**模板泛型**|✅ 支持|❌ 只能用 `void*`|
|**排序方式**|**类型安全**，编译期优化|**运行时比较**，较慢|
|**函数指针调用开销**|❌ 无（内联展开）|✅ 有（函数指针开销）|

**🚀 结论**

- **`std::sort` 比 `qsort()` 快**，因为它使用模板，**不需要函数指针调用**。
- **`std::sort` 更安全**，类型检查在**编译期完成**。

---
### **4️⃣ `std::sort` 的使用示例**

#### **🚀 基本排序**

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> arr = {5, 2, 9, 1, 5, 6};
    std::sort(arr.begin(), arr.end());  // 升序排序
    for (int num : arr) std::cout << num << " ";
    return 0;
}
```

**输出**

```
1 2 5 5 6 9
```

---
#### **🚀 使用自定义比较函数**

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

bool descending(int a, int b) {
    return a > b;
}

int main() {
    std::vector<int> arr = {5, 2, 9, 1, 5, 6};
    std::sort(arr.begin(), arr.end(), descending);  // 降序排序
    for (int num : arr) std::cout << num << " ";
    return 0;
}
```

**输出**

```
9 6 5 5 2 1
```

---
### **📌 结论**

✅ `std::sort` 采用**内省排序（introsort）**，结合**快速排序 + 堆排序 + 插入排序**。  
✅ **快排为主，递归过深时切换堆排，小规模数据用插排**，保证 `O(n log n)` 复杂度。  
✅ **比 `qsort()` 更快**，因为 `std::sort` **是模板函数，避免了函数指针调用开销**。

🚀 **`std::sort` 是 C++ 最快的排序算法，默认选择！** 🔥

---
## **📌 设计模式（Design Pattern）**

### **1️⃣ 什么是设计模式？**

**设计模式** 是**软件开发中的通用解决方案**，用于解决**常见的设计问题**，提高代码的**可读性、可维护性和可复用性**。

✅ **主要作用**

1. **提高代码复用性**：避免重复造轮子，提供**经过验证的最佳实践**。
2. **降低耦合度**：使代码**更灵活、可扩展**，适应未来需求变化。
3. **提高开发效率**：提供**成熟的解决方案**，减少开发成本。

✅ **设计模式 ≠ 具体代码**

- 设计模式是一种**代码组织方式**，可以用 C++、Java、Python 等语言实现。

---
### **2️⃣ 设计模式的分类**

设计模式按照用途分为三大类：

| **类别**                | **作用**        | **常见模式**                                                  |
| --------------------- | ------------- | --------------------------------------------------------- |
| **创建型模式（Creational）** | 负责**对象的创建**   | 单例模式、工厂模式、建造者模式、原型模式                                      |
| **结构型模式（Structural）** | 负责**类和对象的组合** | 适配器模式、装饰器模式、代理模式、桥接模式、组合模式、外观模式、享元模式                      |
| **行为型模式（Behavioral）** | 负责**对象间的交互**  | 观察者模式、策略模式、命令模式、责任链模式、状态模式、模板方法模式、访问者模式、迭代器模式、备忘录模式、解释器模式 |

---
### **3️⃣ 常见的设计模式（示例）**

#### **1️⃣ 单例模式（Singleton Pattern）**

**📌 作用**：保证**全局只有一个实例**，防止重复创建对象（如数据库连接、日志管理）。

**🚀 C++ 实现（懒汉模式，线程安全）**

```cpp
#include <iostream>
#include <mutex>

class Singleton {
private:
    static Singleton* instance;
    static std::mutex mutex;
    Singleton() {}  // 私有构造函数

public:
    static Singleton* getInstance() {
        if (instance == nullptr) {  
            std::lock_guard<std::mutex> lock(mutex);  // 线程安全
            if (instance == nullptr) instance = new Singleton();
        }
        return instance;
    }
};
Singleton* Singleton::instance = nullptr;
std::mutex Singleton::mutex;

int main() {
    Singleton* s1 = Singleton::getInstance();
    Singleton* s2 = Singleton::getInstance();
    std::cout << (s1 == s2) << std::endl;  // 输出 1，证明是同一个实例
}
```

✅ **适用场景**：数据库连接池、日志管理、配置文件管理。

---
#### **2️⃣ 工厂模式（Factory Pattern）**

**📌 作用**：**解耦对象创建过程**，让子类决定实例化哪个类。

**🚀 C++ 实现**

```cpp
#include <iostream>

// 抽象基类
class Animal {
public:
    virtual void speak() = 0;
};

// 具体类
class Dog : public Animal {
public:
    void speak() override { std::cout << "Woof!" << std::endl; }
};

class Cat : public Animal {
public:
    void speak() override { std::cout << "Meow!" << std::endl; }
};

// 工厂类
class AnimalFactory {
public:
    static Animal* createAnimal(const std::string& type) {
        if (type == "dog") return new Dog();
        if (type == "cat") return new Cat();
        return nullptr;
    }
};

int main() {
    Animal* pet = AnimalFactory::createAnimal("dog");
    pet->speak();  // 输出 Woof!
    delete pet;
}
```

✅ **适用场景**：数据库驱动、日志系统、图形库（创建不同形状对象）。

---
#### **3️⃣ 观察者模式（Observer Pattern）**

**📌 作用**：对象状态变化时，通知所有监听者（**发布-订阅模式**）。

**🚀 C++ 实现**

```cpp
#include <iostream>
#include <vector>

// 观察者基类
class Observer {
public:
    virtual void update(int value) = 0;
};

// 具体观察者
class ConcreteObserver : public Observer {
public:
    void update(int value) override { 
        std::cout << "Observer received: " << value << std::endl;
    }
};

// 被观察者
class Subject {
private:
    std::vector<Observer*> observers;
    int state;

public:
    void attach(Observer* obs) { observers.push_back(obs); }
    void setState(int value) {
        state = value;
        notify();
    }
    void notify() {
        for (auto obs : observers) obs->update(state);
    }
};

int main() {
    Subject subject;
    ConcreteObserver obs1, obs2;
    subject.attach(&obs1);
    subject.attach(&obs2);

    subject.setState(10);  // 所有观察者收到 10
}
```

✅ **适用场景**：GUI 事件系统、消息通知、股票行情更新。

---
#### **4️⃣ 适配器模式（Adapter Pattern）**

**📌 作用**：**转换接口**，让旧代码兼容新接口。

**🚀 C++ 实现**

```cpp
#include <iostream>

// 旧接口
class OldPrinter {
public:
    void oldPrint() { std::cout << "Old Printer\n"; }
};

// 适配器
class PrinterAdapter {
private:
    OldPrinter oldPrinter;

public:
    void newPrint() { oldPrinter.oldPrint(); }
};

int main() {
    PrinterAdapter adapter;
    adapter.newPrint();  // 适配器转换调用
}
```

✅ **适用场景**：数据库兼容层、硬件驱动适配、老代码兼容新系统。

---
### **4️⃣ 设计模式的使用场景**

|**模式**|**适用场景**|
|---|---|
|**单例模式**|全局唯一对象，如 **日志、数据库连接**|
|**工厂模式**|对象创建解耦，如 **数据库驱动、图形库**|
|**观察者模式**|事件通知，如 **GUI 事件、消息系统**|
|**适配器模式**|兼容旧代码，如 **数据库兼容层、驱动适配**|
|**策略模式**|可切换算法，如 **支付系统（微信、支付宝）**|
|**状态模式**|状态切换，如 **电梯、游戏 AI**|

---
### **5️⃣ 设计模式的核心原则（SOLID）**

设计模式遵循 **SOLID 原则**，提高代码可维护性：

1. **S** - **单一职责（SRP）**：一个类**只做一件事**。
2. **O** - **开闭原则（OCP）**：**对扩展开放，对修改封闭**。
3. **L** - **里氏替换（LSP）**：子类可以**替换基类**使用。
4. **I** - **接口隔离（ISP）**：**多个小接口**优于**一个大接口**。
5. **D** - **依赖倒置（DIP）**：高层模块**不依赖**底层模块，依赖**抽象**。

---
### **📌 重点总结**

|**问题**|**答案**|
|---|---|
|**设计模式是什么？**|**软件开发中的最佳实践，解决常见设计问题，提高代码复用性**|
|**三大类别？**|**创建型（对象创建）、结构型（对象关系）、行为型（对象交互）**|
|**常见模式？**|**单例模式、工厂模式、观察者模式、适配器模式**|
|**为什么使用设计模式？**|**提高可读性、可维护性、可扩展性**|

🚀 **设计模式是软件开发的最佳实践，掌握它们可以写出更加优雅、可扩展的代码！** 💡🔥

---

C++基础（30题）

1.C++特点

1. ﻿﻿说说C语言和C++的区别
2. ﻿﻿说说 C++中 struct 和class 的区别
3. ﻿﻿include 头文件的顺序以及双引号"和尖括号<>的区

别

1. ﻿﻿说说C++结构体和C结构体的区别
2. ﻿﻿导入C函数的关键字是什么，C++编译时和C有什么不同？

7.C++从代码到可执行二进制文件的过程

1. ﻿﻿说说 static关键字的作用
2. ﻿﻿数组和指针的区别
3. ﻿﻿﻿说说什么是函数指针，如何定义函数指针，有什么使用场景？

2C++内存（30题）

1.简述堆和栈的区别

2.malloc和局部变量分配在堆还是栈？

3.程序有哪些section，分别的作用？程序启动的过
2C++内存（30题）

1.简述堆和栈的区别

2.malloc和局部变量分配在堆还是栈？

3.程序有哪些section，分别的作用？程序启动的过程？

怎么判断数据分配在栈上还是堆上？

1. ﻿﻿初始化为0的全局变量在bss还是 data
2. ﻿﻿简述C++中内存对齐的使用场景
3. ﻿﻿内存泄漏？怎么解决？
4. ﻿﻿说说常见的内存泄漏都有哪些？
5. ﻿﻿如何避免内存泄漏？
6. ﻿﻿你知道常见的内存错误吗？再说说解..
7. ﻿﻿﻿详细说说内存的分配方式？
8. ﻿﻿﻿堆和栈的区别？
9. ﻿﻿﻿如何控制C++的内存分配？
10. ﻿﻿﻿你能讲讲C++内存对齐的使用场景吗？
11. ﻿﻿﻿内存对齐应用于哪几种数据类型及其⋯.
12. ﻿﻿﻿你能说说什么是内存对齐吗？

3 STL（30题）

1. ﻿﻿请说说STL的基本组成部分
2. ﻿﻿请说说 STL 中常见的容器，并介绍一下实现原理
3. ﻿﻿说说 STL中map hashtable deque list的实现原

理

4.请你来介绍一下 STL的空间配置器 （allocator）

5.STL容器用过哪些，查找的时间复杂度是多少

STL（30题）

1. ﻿﻿请说说STL的基本组成部分
2. ﻿﻿请说说STL 中常见的容器，并介绍一下实现原理
3. ﻿﻿说说 STL中map hashtable deque list的实现原

理

4.请你来介绍一下STL的空间配置器（allocator）

5.STL容器用过哪些，查找的时间复杂度是多少，为

什么？

1. ﻿﻿迭代器用过吗？什么时候会失效？
2. ﻿﻿说一下STL中迭代器的作用，有指针为何还要送

代

器？

1. ﻿﻿说说 STL迭代器是怎么删除元素的
2. ﻿﻿说说 STL 中resize 和reserve 的区别
3. ﻿﻿﻿说说 STL容器动态链接可能产生的问题？